import{_ as i,r as o,o as u,c as k,d as a,a as n,w as t,b as s,e as p}from"./app-BamYSO-S.js";const _={},h=n("h1",{id:"epq-支持创建-b-tree-索引并行加速",tabindex:"-1"},[n("a",{class:"header-anchor",href:"#epq-支持创建-b-tree-索引并行加速"},[n("span",null,"ePQ 支持创建 B-Tree 索引并行加速")])],-1),g={class:"table-of-contents"},m=n("h2",{id:"背景",tabindex:"-1"},[n("a",{class:"header-anchor",href:"#背景"},[n("span",null,"背景")])],-1),E=n("p",null,"在使用 PostgreSQL 时，如果想要在一张表中查询符合某个条件的行，默认情况下需要扫描整张表的数据，然后对每一行数据依次判断过滤条件。如果符合条件的行数非常少，而表的数据总量非常大，这显然是一个非常低效的操作。与阅读书籍类似，想要阅读某个特定的章节时，读者通常会通过书籍开头处的索引查询到对应章节的页码，然后直接从指定的页码开始阅读；在数据库中，通常会对被频繁查找的列创建索引，以避免进行开销极大的全表扫描：通过索引可以精确定位到被查找的数据位于哪些数据页面上。",-1),w={href:"https://www.postgresql.org/docs/current/indexes-types.html#INDEXES-TYPES-BTREE",target:"_blank",rel:"noopener noreferrer"},T=p(`<ol><li>顺序扫描表中的每一行数据</li><li>根据要创建索引的列值（Scan Key）顺序，对每行数据在表中的物理位置进行排序</li><li>构建索引元组，按 B-Tree 的结构组织并写入索引页面</li></ol><p>PostgreSQL 支持并行（多进程扫描/排序）和并发（不阻塞 DML）创建索引，但只能在创建索引的过程中使用单个计算节点的资源。</p><p>PolarDB-PG 的 ePQ 弹性跨机并行查询特性支持对 B-Tree 类型的索引创建进行加速。ePQ 能够利用多个计算节点的 I/O 带宽并行扫描全表数据，并利用多个计算节点的 CPU 和内存资源对每行数据在表中的物理位置按索引列值进行排序，构建索引元组。最终，将有序的索引元组归并到创建索引的进程中，写入索引页面，完成索引的创建。</p><h2 id="使用方法" tabindex="-1"><a class="header-anchor" href="#使用方法"><span>使用方法</span></a></h2><h3 id="数据准备" tabindex="-1"><a class="header-anchor" href="#数据准备"><span>数据准备</span></a></h3><p>创建一张包含三个列，数据量为 1000000 行的表：</p><div class="language-sql" data-ext="sql" data-title="sql"><pre class="language-sql"><code><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> t <span class="token punctuation">(</span>id <span class="token keyword">INT</span><span class="token punctuation">,</span> age <span class="token keyword">INT</span><span class="token punctuation">,</span> msg <span class="token keyword">TEXT</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> t
<span class="token keyword">SELECT</span>
    random<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">1000000</span><span class="token punctuation">,</span>
    random<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">10000</span><span class="token punctuation">,</span>
    md5<span class="token punctuation">(</span>random<span class="token punctuation">(</span><span class="token punctuation">)</span>::<span class="token keyword">text</span><span class="token punctuation">)</span>
<span class="token keyword">FROM</span> generate_series<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1000000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><h3 id="创建索引" tabindex="-1"><a class="header-anchor" href="#创建索引"><span>创建索引</span></a></h3><p>使用 ePQ 创建索引需要以下三个步骤：</p><ol><li>设置参数 <code>polar_enable_px</code> 为 <code>ON</code>，打开 ePQ 的开关</li><li>按需设置参数 <code>polar_px_dop_per_node</code> 调整查询并行度</li><li>在创建索引时显式声明 <code>px_build</code> 属性为 <code>ON</code></li></ol><div class="language-sql" data-ext="sql" data-title="sql"><pre class="language-sql"><code><span class="token keyword">SET</span> polar_enable_px <span class="token keyword">TO</span> <span class="token keyword">ON</span><span class="token punctuation">;</span>
<span class="token keyword">SET</span> polar_px_dop_per_node <span class="token keyword">TO</span> <span class="token number">8</span><span class="token punctuation">;</span>
<span class="token keyword">CREATE</span> <span class="token keyword">INDEX</span> t_idx1 <span class="token keyword">ON</span> t<span class="token punctuation">(</span>id<span class="token punctuation">,</span> msg<span class="token punctuation">)</span> <span class="token keyword">WITH</span><span class="token punctuation">(</span>px_build <span class="token operator">=</span> <span class="token keyword">ON</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div>`,11),x={href:"https://www.postgresql.org/docs/current/explicit-locking.html#LOCKING-TABLES",target:"_blank",rel:"noopener noreferrer"},f=n("code",null,"ShareLock",-1),y=n("code",null,"INSERT",-1),N=n("code",null,"UPDATE",-1),b=n("code",null,"DELETE",-1),v=p(`<h3 id="并发创建索引" tabindex="-1"><a class="header-anchor" href="#并发创建索引"><span>并发创建索引</span></a></h3><p>类似地，ePQ 支持并发创建索引，只需要在 <code>CREATE INDEX</code> 后加上 <code>CONCURRENTLY</code> 关键字即可：</p><div class="language-sql" data-ext="sql" data-title="sql"><pre class="language-sql"><code><span class="token keyword">SET</span> polar_enable_px <span class="token keyword">TO</span> <span class="token keyword">ON</span><span class="token punctuation">;</span>
<span class="token keyword">SET</span> polar_px_dop_per_node <span class="token keyword">TO</span> <span class="token number">8</span><span class="token punctuation">;</span>
<span class="token keyword">CREATE</span> <span class="token keyword">INDEX</span> CONCURRENTLY t_idx2 <span class="token keyword">ON</span> t<span class="token punctuation">(</span>id<span class="token punctuation">,</span> msg<span class="token punctuation">)</span> <span class="token keyword">WITH</span><span class="token punctuation">(</span>px_build <span class="token operator">=</span> <span class="token keyword">ON</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div>`,3),q={href:"https://www.postgresql.org/docs/current/explicit-locking.html#LOCKING-TABLES",target:"_blank",rel:"noopener noreferrer"},I=n("code",null,"ShareUpdateExclusiveLock",-1),L=p('<h2 id="使用限制" tabindex="-1"><a class="header-anchor" href="#使用限制"><span>使用限制</span></a></h2><p>ePQ 加速创建索引暂不支持以下场景：</p><ul><li>创建 <code>UNIQUE</code> 索引</li><li>创建索引时附带 <code>INCLUDING</code> 列</li><li>创建索引时指定 <code>TABLESPACE</code></li><li>创建索引时带有 <code>WHERE</code> 而成为部分索引（Partial Index）</li></ul>',3);function S(c,O){const r=o("Badge"),d=o("ArticleInfo"),e=o("router-link"),l=o("ExternalLinkIcon");return u(),k("div",null,[h,a(r,{type:"tip",text:"V11 / v1.1.15-",vertical:"top"}),a(d,{frontmatter:c.$frontmatter},null,8,["frontmatter"]),n("nav",g,[n("ul",null,[n("li",null,[a(e,{to:"#背景"},{default:t(()=>[s("背景")]),_:1})]),n("li",null,[a(e,{to:"#使用方法"},{default:t(()=>[s("使用方法")]),_:1}),n("ul",null,[n("li",null,[a(e,{to:"#数据准备"},{default:t(()=>[s("数据准备")]),_:1})]),n("li",null,[a(e,{to:"#创建索引"},{default:t(()=>[s("创建索引")]),_:1})]),n("li",null,[a(e,{to:"#并发创建索引"},{default:t(()=>[s("并发创建索引")]),_:1})])])]),n("li",null,[a(e,{to:"#使用限制"},{default:t(()=>[s("使用限制")]),_:1})])])]),m,E,n("p",null,[s("PostgreSQL 支持创建多种类型的索引，其中使用得最多的是 "),n("a",w,[s("B-Tree"),a(l)]),s(" 索引，也是 PostgreSQL 默认创建的索引类型。在一张数据量较大的表上创建索引是一件非常耗时的事，因为其中涉及到的工作包含：")]),T,n("p",null,[s("在创建索引的过程中，数据库会对正在创建索引的表施加 "),n("a",x,[f,a(l)]),s(" 锁。这个级别的锁将会阻塞其它进程对表的 DML 操作（"),y,s(" / "),N,s(" / "),b,s("）。")]),v,n("p",null,[s("在创建索引的过程中，数据库会对正在创建索引的表施加 "),n("a",q,[I,a(l)]),s(" 锁。这个级别的锁将不会阻塞其它进程对表的 DML 操作。")]),L])}const C=i(_,[["render",S],["__file","epq-create-btree-index.html.vue"]]),B=JSON.parse('{"path":"/zh/features/v11/epq/epq-create-btree-index.html","title":"ePQ 支持创建 B-Tree 索引并行加速","lang":"zh-CN","frontmatter":{"author":"棠羽","date":"2023/09/20","minute":20},"headers":[{"level":2,"title":"背景","slug":"背景","link":"#背景","children":[]},{"level":2,"title":"使用方法","slug":"使用方法","link":"#使用方法","children":[{"level":3,"title":"数据准备","slug":"数据准备","link":"#数据准备","children":[]},{"level":3,"title":"创建索引","slug":"创建索引","link":"#创建索引","children":[]},{"level":3,"title":"并发创建索引","slug":"并发创建索引","link":"#并发创建索引","children":[]}]},{"level":2,"title":"使用限制","slug":"使用限制","link":"#使用限制","children":[]}],"git":{"updatedTime":1731551625000,"contributors":[{"name":"mrdrivingduck","email":"mrdrivingduck@gmail.com","commits":1}]},"filePathRelative":"zh/features/v11/epq/epq-create-btree-index.md"}');export{C as comp,B as data};
