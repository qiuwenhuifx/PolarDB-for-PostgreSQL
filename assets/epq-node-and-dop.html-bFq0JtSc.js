import{_ as r,r as o,o as k,c as d,d as n,a as s,w as p,e as u,b as e}from"./app-BamYSO-S.js";const i={},m=s("h1",{id:"epq-计算节点范围选择与并行度控制",tabindex:"-1"},[s("a",{class:"header-anchor",href:"#epq-计算节点范围选择与并行度控制"},[s("span",null,"ePQ 计算节点范围选择与并行度控制")])],-1),_={class:"table-of-contents"},w=u(`<h2 id="背景介绍" tabindex="-1"><a class="header-anchor" href="#背景介绍"><span>背景介绍</span></a></h2><p>PolarDB-PG 的 ePQ 弹性跨机并行查询特性提供了精细的粒度控制方法，可以合理使用集群内的计算资源。在最大程度利用闲置计算资源进行并行查询，提升资源利用率的同时，避免了对其它业务负载产生影响：</p><ol><li>ePQ 可以动态调整集群中参与并行查询的计算节点范围，避免使用负载较高的计算节点</li><li>ePQ 支持为每条查询动态调整在计算节点上的并行度，避免 ePQ 并行查询进程对计算资源的消耗影响到相同节点上的其它进程</li></ol><h2 id="计算节点范围选择" tabindex="-1"><a class="header-anchor" href="#计算节点范围选择"><span>计算节点范围选择</span></a></h2><p>参数 <code>polar_px_nodes</code> 指定了参与 ePQ 的计算节点范围，默认值为空，表示所有只读节点都参与 ePQ 并行查询：</p><div class="language-sql" data-ext="sql" data-title="sql"><pre class="language-sql"><code><span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token keyword">SHOW</span> polar_px_nodes<span class="token punctuation">;</span>
 polar_px_nodes
<span class="token comment">----------------</span>

<span class="token punctuation">(</span><span class="token number">1</span> <span class="token keyword">row</span><span class="token punctuation">)</span>
</code></pre></div><p>如果希望读写节点也参与 ePQ 并行，则可以设置如下参数：</p><div class="language-sql" data-ext="sql" data-title="sql"><pre class="language-sql"><code><span class="token keyword">SET</span> polar_px_use_primary <span class="token keyword">TO</span> <span class="token keyword">ON</span><span class="token punctuation">;</span>
</code></pre></div><p>如果部分只读节点负载较高，则可以通过修改 <code>polar_px_nodes</code> 参数设置仅特定几个而非所有只读节点参与 ePQ 并行查询。参数 <code>polar_px_nodes</code> 的合法格式是一个以英文逗号分隔的节点名称列表。获取节点名称需要安装 <code>polar_monitor</code> 插件：</p><div class="language-sql" data-ext="sql" data-title="sql"><pre class="language-sql"><code><span class="token keyword">CREATE</span> EXTENSION <span class="token keyword">IF</span> <span class="token operator">NOT</span> <span class="token keyword">EXISTS</span> polar_monitor<span class="token punctuation">;</span>
</code></pre></div><p>通过 <code>polar_monitor</code> 插件提供的集群拓扑视图，可以查询到集群中所有计算节点的名称：</p><div class="language-sql" data-ext="sql" data-title="sql"><pre class="language-sql"><code><span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token keyword">SELECT</span> name<span class="token punctuation">,</span>slot_name<span class="token punctuation">,</span><span class="token keyword">type</span> <span class="token keyword">FROM</span> polar_cluster_info<span class="token punctuation">;</span>
 name  <span class="token operator">|</span> slot_name <span class="token operator">|</span>  <span class="token keyword">type</span>
<span class="token comment">-------+-----------+---------</span>
 node0 <span class="token operator">|</span>           <span class="token operator">|</span> <span class="token keyword">Primary</span>
 node1 <span class="token operator">|</span> standby1  <span class="token operator">|</span> Standby
 node2 <span class="token operator">|</span> replica1  <span class="token operator">|</span> Replica
 node3 <span class="token operator">|</span> replica2  <span class="token operator">|</span> Replica
<span class="token punctuation">(</span><span class="token number">4</span> <span class="token keyword">rows</span><span class="token punctuation">)</span>
</code></pre></div><p>其中：</p><ul><li><code>Primary</code> 表示读写节点</li><li><code>Replica</code> 表示只读节点</li><li><code>Standby</code> 表示备库节点</li></ul><p>通用的最佳实践是使用负载较低的只读节点参与 ePQ 并行查询：</p><div class="language-sql" data-ext="sql" data-title="sql"><pre class="language-sql"><code><span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token keyword">SET</span> polar_px_nodes <span class="token operator">=</span> <span class="token string">&#39;node2,node3&#39;</span><span class="token punctuation">;</span>
<span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token keyword">SHOW</span> polar_px_nodes<span class="token punctuation">;</span>
 polar_px_nodes
<span class="token comment">----------------</span>
 node2<span class="token punctuation">,</span>node3
<span class="token punctuation">(</span><span class="token number">1</span> <span class="token keyword">row</span><span class="token punctuation">)</span>
</code></pre></div><h2 id="并行度控制" tabindex="-1"><a class="header-anchor" href="#并行度控制"><span>并行度控制</span></a></h2><p>参数 <code>polar_px_dop_per_node</code> 用于设置当前会话中的 ePQ 查询在每个计算节点上的执行单元（Segment）数量，每个执行单元会为其需要执行的每一个计划分片（Slice）启动一个进程。</p><p>该参数默认值为 <code>3</code>，通用最佳实践值为当前计算节点 CPU 核心数的一半。如果计算节点的 CPU 负载较高，可以酌情递减该参数，控制计算节点的 CPU 占用率至 80% 以下；如果查询性能不佳时，可以酌情递增该参数，也需要保持计算节点的 CPU 水位不高于 80%。否则可能会拖慢其它的后台进程。</p><h2 id="并行度计算方法示例" tabindex="-1"><a class="header-anchor" href="#并行度计算方法示例"><span>并行度计算方法示例</span></a></h2><p>创建一张表：</p><div class="language-sql" data-ext="sql" data-title="sql"><pre class="language-sql"><code><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> test<span class="token punctuation">(</span>id <span class="token keyword">INT</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>假设集群内有两个只读节点，<code>polar_px_nodes</code> 为空，此时 ePQ 将使用集群内的所有只读节点参与并行查询；参数 <code>polar_px_dop_per_node</code> 的值为 <code>3</code>，表示每个计算节点上将会有三个执行单元。执行计划如下：</p><div class="language-sql" data-ext="sql" data-title="sql"><pre class="language-sql"><code><span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token keyword">SHOW</span> polar_px_nodes<span class="token punctuation">;</span>
 polar_px_nodes
<span class="token comment">----------------</span>

<span class="token punctuation">(</span><span class="token number">1</span> <span class="token keyword">row</span><span class="token punctuation">)</span>

<span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token keyword">SHOW</span> polar_px_dop_per_node<span class="token punctuation">;</span>
 polar_px_dop_per_node
<span class="token comment">-----------------------</span>
 <span class="token number">3</span>
<span class="token punctuation">(</span><span class="token number">1</span> <span class="token keyword">row</span><span class="token punctuation">)</span>

<span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token keyword">EXPLAIN</span> <span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> test<span class="token punctuation">;</span>
                                  QUERY <span class="token keyword">PLAN</span>
<span class="token comment">-------------------------------------------------------------------------------</span>
 PX Coordinator <span class="token number">6</span>:<span class="token number">1</span>  <span class="token punctuation">(</span>slice1<span class="token punctuation">;</span> segments: <span class="token number">6</span><span class="token punctuation">)</span>  <span class="token punctuation">(</span>cost<span class="token operator">=</span><span class="token number">0.00</span><span class="token punctuation">.</span><span class="token number">.431</span><span class="token number">.00</span> <span class="token keyword">rows</span><span class="token operator">=</span><span class="token number">1</span> width<span class="token operator">=</span><span class="token number">4</span><span class="token punctuation">)</span>
   <span class="token operator">-</span><span class="token operator">&gt;</span>  <span class="token keyword">Partial</span> Seq Scan <span class="token keyword">on</span> test  <span class="token punctuation">(</span>cost<span class="token operator">=</span><span class="token number">0.00</span><span class="token punctuation">.</span><span class="token number">.431</span><span class="token number">.00</span> <span class="token keyword">rows</span><span class="token operator">=</span><span class="token number">1</span> width<span class="token operator">=</span><span class="token number">4</span><span class="token punctuation">)</span>
 Optimizer: PolarDB PX Optimizer
<span class="token punctuation">(</span><span class="token number">3</span> <span class="token keyword">rows</span><span class="token punctuation">)</span>
</code></pre></div><p>从执行计划中可以看出，两个只读节点上总计有六个执行单元（<code>segments: 6</code>）将会执行这个计划中唯一的计划分片 <code>slice1</code>。这意味着总计会有六个进程并行执行当前查询。</p><p>此时，调整 <code>polar_px_dop_per_node</code> 为 <code>4</code>，再次执行查询，两个只读节点上总计会有八个执行单元参与当前查询。由于执行计划中只有一个计划分片 <code>slice1</code>，这意味着总计会有八个进程并行执行当前查询：</p><div class="language-sql" data-ext="sql" data-title="sql"><pre class="language-sql"><code><span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token keyword">SET</span> polar_px_dop_per_node <span class="token keyword">TO</span> <span class="token number">4</span><span class="token punctuation">;</span>
<span class="token keyword">SET</span>
<span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token keyword">EXPLAIN</span> <span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> test<span class="token punctuation">;</span>
                                  QUERY <span class="token keyword">PLAN</span>
<span class="token comment">-------------------------------------------------------------------------------</span>
 PX Coordinator <span class="token number">8</span>:<span class="token number">1</span>  <span class="token punctuation">(</span>slice1<span class="token punctuation">;</span> segments: <span class="token number">8</span><span class="token punctuation">)</span>  <span class="token punctuation">(</span>cost<span class="token operator">=</span><span class="token number">0.00</span><span class="token punctuation">.</span><span class="token number">.431</span><span class="token number">.00</span> <span class="token keyword">rows</span><span class="token operator">=</span><span class="token number">1</span> width<span class="token operator">=</span><span class="token number">4</span><span class="token punctuation">)</span>
   <span class="token operator">-</span><span class="token operator">&gt;</span>  <span class="token keyword">Partial</span> Seq Scan <span class="token keyword">on</span> test  <span class="token punctuation">(</span>cost<span class="token operator">=</span><span class="token number">0.00</span><span class="token punctuation">.</span><span class="token number">.431</span><span class="token number">.00</span> <span class="token keyword">rows</span><span class="token operator">=</span><span class="token number">1</span> width<span class="token operator">=</span><span class="token number">4</span><span class="token punctuation">)</span>
 Optimizer: PolarDB PX Optimizer
<span class="token punctuation">(</span><span class="token number">3</span> <span class="token keyword">rows</span><span class="token punctuation">)</span>
</code></pre></div><p>此时，如果设置 <code>polar_px_use_primary</code> 参数，让读写节点也参与查询，那么读写节点上也将会有四个执行单元参与 ePQ 并行执行，集群内总计 12 个进程参与并行执行：</p><div class="language-sql" data-ext="sql" data-title="sql"><pre class="language-sql"><code><span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token keyword">SET</span> polar_px_use_primary <span class="token keyword">TO</span> <span class="token keyword">ON</span><span class="token punctuation">;</span>
<span class="token keyword">SET</span>
<span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token keyword">EXPLAIN</span> <span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> test<span class="token punctuation">;</span>
                                   QUERY <span class="token keyword">PLAN</span>
<span class="token comment">---------------------------------------------------------------------------------</span>
 PX Coordinator <span class="token number">12</span>:<span class="token number">1</span>  <span class="token punctuation">(</span>slice1<span class="token punctuation">;</span> segments: <span class="token number">12</span><span class="token punctuation">)</span>  <span class="token punctuation">(</span>cost<span class="token operator">=</span><span class="token number">0.00</span><span class="token punctuation">.</span><span class="token number">.431</span><span class="token number">.00</span> <span class="token keyword">rows</span><span class="token operator">=</span><span class="token number">1</span> width<span class="token operator">=</span><span class="token number">4</span><span class="token punctuation">)</span>
   <span class="token operator">-</span><span class="token operator">&gt;</span>  <span class="token keyword">Partial</span> Seq Scan <span class="token keyword">on</span> test  <span class="token punctuation">(</span>cost<span class="token operator">=</span><span class="token number">0.00</span><span class="token punctuation">.</span><span class="token number">.431</span><span class="token number">.00</span> <span class="token keyword">rows</span><span class="token operator">=</span><span class="token number">1</span> width<span class="token operator">=</span><span class="token number">4</span><span class="token punctuation">)</span>
 Optimizer: PolarDB PX Optimizer
<span class="token punctuation">(</span><span class="token number">3</span> <span class="token keyword">rows</span><span class="token punctuation">)</span>
</code></pre></div>`,29);function y(t,g){const c=o("Badge"),l=o("ArticleInfo"),a=o("router-link");return k(),d("div",null,[m,n(c,{type:"tip",text:"V11 / v1.1.20-",vertical:"top"}),n(l,{frontmatter:t.$frontmatter},null,8,["frontmatter"]),s("nav",_,[s("ul",null,[s("li",null,[n(a,{to:"#背景介绍"},{default:p(()=>[e("背景介绍")]),_:1})]),s("li",null,[n(a,{to:"#计算节点范围选择"},{default:p(()=>[e("计算节点范围选择")]),_:1})]),s("li",null,[n(a,{to:"#并行度控制"},{default:p(()=>[e("并行度控制")]),_:1})]),s("li",null,[n(a,{to:"#并行度计算方法示例"},{default:p(()=>[e("并行度计算方法示例")]),_:1})])])]),w])}const h=r(i,[["render",y],["__file","epq-node-and-dop.html.vue"]]),q=JSON.parse('{"path":"/zh/features/v11/epq/epq-node-and-dop.html","title":"ePQ 计算节点范围选择与并行度控制","lang":"zh-CN","frontmatter":{"author":"渊云","date":"2023/09/06","minute":20},"headers":[{"level":2,"title":"背景介绍","slug":"背景介绍","link":"#背景介绍","children":[]},{"level":2,"title":"计算节点范围选择","slug":"计算节点范围选择","link":"#计算节点范围选择","children":[]},{"level":2,"title":"并行度控制","slug":"并行度控制","link":"#并行度控制","children":[]},{"level":2,"title":"并行度计算方法示例","slug":"并行度计算方法示例","link":"#并行度计算方法示例","children":[]}],"git":{"updatedTime":1731551625000,"contributors":[{"name":"mrdrivingduck","email":"mrdrivingduck@gmail.com","commits":1}]},"filePathRelative":"zh/features/v11/epq/epq-node-and-dop.md"}');export{h as comp,q as data};
